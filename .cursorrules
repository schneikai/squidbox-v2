# Cursor Rules

This file defines rules for the coding agent. Add new rules when the agent repeatedly suggests code that doesn't align with your project's requirements, specifications, or coding style, and you find yourself consistently correcting the same issues. This helps the agent understand your project's specific patterns and conventions, but also keeps the size of the rules file manageable. Don't add rules for things the agent already handles correctly.

**Rule Guidelines**

- Keep rules short and actionable
- Keep rules current: update them when needed and remove those that are obsolete
- Code snippets are optional. Do not add a snippet if the rule is already clear without it
- Organize into the existing categories. New categories can be added if necessary
- Do not use emojis

## Project Overview

Squidbox is a social media cross-posting App that allows users to publish content to multiple social platforms simultaneously. The project is structured as a TypeScript monorepo with a mobile-first approach, featuring an Expo React Native app for content creation and an Express.js backend for platform integration and post management.

The architecture includes:

- **Mobile App** (`apps/mobile`): Expo React Native app with cross-platform posting capabilities
- **API Backend** (`apps/api`): Express.js server with PostgreSQL database, OAuth token management, and background job processing
- **Shared Contracts** (`packages/contracts`): TypeScript types and Zod schemas shared between frontend and backend
- **Twitter API Package** (`packages/twitter-api`): Dedicated Twitter/X integration utilities

The platform supports multiple social media platforms including Twitter/X, Bluesky, OnlyFans, and JFF (Just For Fans), with OAuth-based authentication and secure token storage. Users can compose posts with media attachments and distribute them across connected platforms with status tracking and error handling.

Key technologies: React Native, Expo, TypeScript, Express.js, PostgreSQL, Prisma, BullMQ, Redis, pnpm, Turbo, Vitest, Zod.

## General Conventions

<!-- Add rules about tone, style, naming, project-wide patterns -->

- Always run `nvm use` first before starting a new terminal session to ensure the correct Node version
- Use pnpm instead of npm for package management commands.
- Add comments when business logic needs additional explanation, not just restate the code
- Leave debug console.log statements added during active development and ignore the linter warnings - these are temporary and will be cleaned up when development is complete

## TypeScript

<!-- Add rules for typing, defaults, null/undefined handling, generics -->

- Let the database handle ID generation instead of manually creating IDs (use `@default(cuid())` in Prisma schema)
- Use Prisma-generated types from `@prisma/client` for database operations instead of manual type definitions
- Prefer throwing errors over returning error objects - let consumers handle errors
- Remove unnecessary try/catch blocks - only use for cleanup operations

## React

<!-- Add rules for hooks, components, props, rendering patterns -->

## UI / Styling

<!-- Add rules for Chakra UI, theming, design tokens, component styling -->

## Database

<!-- Add rules for Prisma, PostgreSQL, schema design -->

- Prefer normalized database structures over JSON storage for better querying and maintainability
- Use CUIDs for distributed systems (better than UUIDs for sortable, collision-resistant IDs)
- Create junction tables for many-to-many relationships instead of storing arrays in JSON
- Use Prisma enums for type safety instead of string fields with manual validation
- Reset database during development instead of creating migrations (`npx prisma db push --force-reset`)

## Queue & Workers

<!-- Add rules for BullMQ, Redis, background job processing -->

- Handle job retries and error states properly in worker event handlers like worker.on 'failed', 'completed', 'error', etc.

## Testing

<!-- Add rules for Jest, Cypress, selectors, intercepts -->

- to run all tests in the monorepo, use: `cd /Users/kai/Development/squidbox-v2 && nvm use && pnpm test`
- to run all tests in a specific package, use: `cd /Users/kai/Development/squidbox-v2/apps/api && nvm use && pnpm test`
- to run a single test, use: `cd /Users/kai/Development/squidbox-v2/apps/api && nvm use && pnpm test test/filename.test.ts`
- Always import `apps/api/test/setup.ts` FIRST in all test files in the api package to ensure proper setup of the test environment

### Worker Testing

- Use real Redis and BullMQ in tests instead of mocking queue infrastructure; we have Redis running in tests
- Start workers after database setup to ensure they use the same database connection as tests
- Use `await startWorker(() => startWorkerFunction())` utility for starting workers in tests
- Use `await waitForJobState(job, 'completed')` and `await waitForJobState(job, 'failed')` for job state verification
- Use `createTestJobOptions()` for fast retry settings in tests (100ms fixed delay instead of exponential backoff)
- Mock only external dependencies (like HTTP requests) but keep queue and database operations real
